+++
date = "2016-02-04T12:33:23+08:00"
draft = false
title = "CodecDraft"

+++

## Base64 认识
### 背景
今天有一个同事需要在函数调用的时候, 输入 `foo bar` 内容, 但是没有处理好空格, 同时又由于中间有", 
导致问题处理比较棘手, 后来直接采用 `base64 <<< 'foo bar'`, 然后在脚本内部再进行 base64 decode, 来进行.  

### Base64 背景
为什么会有 Base64 编码?  因为有些网络传输不支持所有字节, 比如传统的邮件只支持可见字符, 像 ASCII 码的控制字符就不能通过邮件传输.  
这样用途上会进行比较大的限制, 比如图片二进制流的每个字节不可能都是可见字符, 所以就传输不了. 
为了考虑线下兼容, 在不改变传统协议的情况下, 我们希望能够有一个扩展的方案来支持二进制文件的传输, 
把不可打印的字符, 也可以用打印字符表示出来. Base64 就是一种基于64个可打印字符来表示二进制的数据表示方法.  

### Base64 编码原理
Base64 索引表, 采用" A-Z, a-z, 0-9, +, /" 一共64个字符, 因此只需要6bit 来表示就够了. 
那么如何用6个 bit 来表示传统中的8个 bit的字符呢?   8 和 6 的最小公倍数是24, 因此3各传统自己一组, 利用4各 Base64
字符进行表示. 存储的时候会在6 bit 的开头(左边最高2位) 补上两个0.  
比如:  Iam 使用  SWFt 来表示  
既然3个一组来表示 Base64, 那么如果是1个或者是2个怎么办 ?    
在 Base64 是使用 = 来进行填充( padding ), 因此我们经常可以看到Base64 字符最后是 == 或者是 =.   

#### padding 里边 = 是否是必须的?  
在 Base64 encoding 的时候`==`  是为了 padding,  在 decoding 的时候会跳过`=`, 因此本质上是可以忽略的. 
当时为了多段编码后的Base64字符串拼起来也不会引起混淆, 所以一般不会进行忽略. 

